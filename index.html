<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binary Dome to Vimana</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
    }
    #ui {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      z-index: 10;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 18px;
      border-radius: 20px;
      border: none;
      background: #00cfff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="detonate">Detonate</button>
    <button id="reform">Reform</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Binary Particles
    const particleCount = 5000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount * 3);
    const binary = [];

    function randomBinary() {
      return Math.random() > 0.5 ? 1 : 0;
    }

    // Start positions = dome-shaped
    function generateDome() {
      for (let i = 0; i < particleCount; i++) {
        const phi = Math.random() * Math.PI; // angle
        const theta = Math.random() * Math.PI * 2;
        const radius = 30;
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = Math.abs(radius * Math.cos(phi));
        const z = radius * Math.sin(phi) * Math.sin(theta);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        speeds[i * 3] = (Math.random() - 0.5) * 3;
        speeds[i * 3 + 1] = (Math.random() - 0.5) * 3;
        speeds[i * 3 + 2] = (Math.random() - 0.5) * 3;

        binary[i] = randomBinary();
      }
    }

    generateDome();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    // Material that displays 1s and 0s
    const sprite = new THREE.CanvasTexture(generateTextSprite());

    function generateTextSprite(color = "#00ff55") {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = color;
      ctx.font = "bold 48px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(Math.random() > 0.5 ? "1" : "0", 32, 32);
      return canvas;
    }

    const material = new THREE.PointsMaterial({
      size: 1.8,
      map: sprite,
      transparent: true,
      depthWrite: false
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Animation flags
    let detonated = false;
    let reforming = false;

    document.getElementById("detonate").onclick = () => {
      detonated = true;
      reforming = false;
    };

    document.getElementById("reform").onclick = () => {
      detonated = false;
      reforming = true;
      material.map = new THREE.CanvasTexture(generateTextSprite("#ff8800"));
      reformToVimana();
    };

    // Reform target = Vimana shape
    const targetPositions = new Float32Array(particleCount * 3);

    function reformToVimana() {
      for (let i = 0; i < particleCount; i++) {
        const height = Math.random() * 40;
        const radius = (40 - height) * 0.5;
        const angle = Math.random() * Math.PI * 2;
        const x = radius * Math.cos(angle);
        const y = height;
        const z = radius * Math.sin(angle);
        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;
      }
    }

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);

      const pos = geometry.attributes.position.array;

      if (detonated) {
        for (let i = 0; i < particleCount; i++) {
          pos[i * 3] += speeds[i * 3];
          pos[i * 3 + 1] += speeds[i * 3 + 1];
          pos[i * 3 + 2] += speeds[i * 3 + 2];
        }
      }

      if (reforming) {
        for (let i = 0; i < particleCount; i++) {
          pos[i * 3] += (targetPositions[i * 3] - pos[i * 3]) * 0.02;
          pos[i * 3 + 1] += (targetPositions[i * 3 + 1] - pos[i * 3 + 1]) * 0.02;
          pos[i * 3 + 2] += (targetPositions[i * 3 + 2] - pos[i * 3 + 2]) * 0.02;
        }
      }

      geometry.attributes.position.needsUpdate = true;
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

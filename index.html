<!DOCTYPE html><html><head><meta charset="utf-8"><title>Binary Dome to Temple Vimana</title><meta name="viewport" content="width=device-width,initial-scale=1">
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<style>
body{margin:0;background:#06080b;overflow:hidden}
button{position:absolute;top:16px;padding:10px 18px;border:none;border-radius:999px;background:#00d4ff;color:#031217;font-weight:700;cursor:pointer;box-shadow:0 8px 24px rgba(0,212,255,.25)}
#d{left:calc(50% - 90px)}#r{left:calc(50% + 10px)}
</style></head><body>
<button id="d" onclick="detonate()">Detonate</button>
<button id="r" onclick="reform()">Reform</button>
<script>
const scene=new THREE.Scene(),camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,.1,3000),renderer=new THREE.WebGLRenderer({antialias:true});
camera.position.set(0,80,280);renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(2,devicePixelRatio));renderer.outputColorSpace=THREE.SRGBColorSpace;document.body.appendChild(renderer.domElement);
const hemi=new THREE.HemisphereLight(0x99ffcc,0x0a0c10,.9),rim=new THREE.DirectionalLight(0xffaa22,1.15);rim.position.set(-140,90,-80);scene.add(hemi,rim);

// Digit textures
function tex(ch,col){const s=128,c=document.createElement("canvas");c.width=s;c.height=s;const x=c.getContext("2d")
x.fillStyle=col;x.font="bold 96px monospace";x.textAlign="center";x.textBaseline="middle";x.fillText(ch,s/2,s/2)
const t=new THREE.CanvasTexture(c);t.colorSpace=THREE.SRGBColorSpace;return t}
const G1=tex("1","#00ff77"),G0=tex("0","#00ff77"),O1=tex("1","#ff7a00"),O0=tex("0","#ff7a00")
function sprite(map){return new THREE.Sprite(new THREE.SpriteMaterial({map:map,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false}))}

const group=new THREE.Group();scene.add(group)
const radius=110, domeRows=80, domeCols=160, tiers=24, tierHeight=6.5, columnSpacing=4.5, jitter=0.35
const digits=[], domePos=[], templePos=[]

// Build dense green dome
for(let i=0;i<=domeRows;i++){
  const v=i/domeRows, phi=v*Math.PI/2, ringR=Math.cos(phi)*radius, y=Math.sin(phi)*radius
  const ringCount=Math.max(20,Math.floor(domeCols*Math.cos(phi)))
  for(let j=0;j<ringCount;j++){
    const u=j/ringCount, theta=u*2*Math.PI
    const x=Math.cos(theta)*ringR, z=Math.sin(theta)*ringR
    const pos=new THREE.Vector3(x+(Math.random()-0.5)*jitter,y+(Math.random()-0.5)*jitter,z+(Math.random()-0.5)*jitter)
    const s=sprite(Math.random()<0.5?G1:G0)
    const depth=pos.length(), scale=1.6-0.5*Math.min(1,depth/(radius*1.25))
    s.scale.set(scale,scale,1);s.material.opacity=0.52+0.42*Math.exp(-Math.abs(y)/radius*0.85)
    s.position.copy(pos);group.add(s);digits.push(s);domePos.push(pos.clone())
  }
}

// Build temple columns
(function buildTemple(){
  const N=domePos.length, positions=[]
  for(let lvl=0;lvl<tiers;lvl++){
    const t=1-lvl/(tiers-1), scale=0.85*Math.pow(t,0.95), width=radius*0.9*scale, depth=radius*0.7*scale, y=lvl*tierHeight
    const colsX=Math.max(6,Math.round(28*scale)), colsZ=Math.max(6,Math.round(22*scale))
    for(let ix=0;ix<colsX;ix++){
      const fx=ix/(colsX-1)*2-1, x=fx*width+(Math.random()-0.5)*jitter
      for(let iz=0;iz<colsZ;iz++){
        const fz=iz/(colsZ-1)*2-1, z=fz*depth+(Math.random()-0.5)*jitter
        const levels=Math.max(2,Math.round(3+4*(1-y/(tiers*tierHeight+1))))
        for(let c=0;c<levels;c++){positions.push(new THREE.Vector3(x,y+c*columnSpacing,z))}
      }
    }
  }
  for(let k=0;k<20;k++){
    const yy=tiers*tierHeight+k*(columnSpacing*0.7), spread=Math.max(2.5,8*Math.pow(1-k/19,1.2)), count=24
    for(let j=0;j<count;j++){
      const ang=j/count*2*Math.PI, x=Math.cos(ang)*spread*0.4+(Math.random()-0.5)*jitter*0.6, z=Math.sin(ang)*spread*0.4+(Math.random()-0.5)*jitter*0.6
      positions.push(new THREE.Vector3(x,yy,z))
    }
  }
  if(positions.length>=N) templePos.push(...positions.slice(0,N))
  else{templePos.push(...positions);let idx=0;while(templePos.length<N){templePos.push(positions[idx++%positions.length])}}
})()

function detonate(){
  digits.forEach(s=>{
    const outward=s.position.clone().normalize(), rnd=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize()
    s.userData.v=outward.multiplyScalar(28*(0.6+Math.random())).add(rnd.multiplyScalar(36*(0.4+Math.random())))
  })
}
function reform(){
  digits.forEach((s,i)=>{
    s.material.map=Math.random()<0.5?O1:O0
    gsap.to(s.position,{x:templePos[i].x,y:templePos[i].y,z:templePos[i].z,duration:2.0,ease:"power3.out"})
    s.userData.v=null
  })
}

let t=0
function animate(){
  requestAnimationFrame(animate);t+=0.01
  group.rotation.y=Math.sin(t*0.30)*0.13;group.rotation.x=Math.cos(t*0.22)*0.06
  const dt=0.016
  digits.forEach(s=>{
    const v=s.userData.v
    if(v){s.position.addScaledVector(v,dt);v.multiplyScalar(0.984);s.material.opacity=Math.max(0.28,s.material.opacity*0.992)}
    else{s.material.opacity=Math.min(0.98,s.material.opacity+0.002)}
  })
  renderer.render(scene,camera)
}
animate()
onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)}
</script></body></html>


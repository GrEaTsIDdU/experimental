<!DOCTYPE html><html><head><meta charset="utf-8"><title>Binary Temple</title><meta name="viewport" content="width=device-width,initial-scale=1">
<script src="https://unpkg.com/three@0.152.2/build/three.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" crossorigin="anonymous"></script>
<style>
body{margin:0;background:#06080b;overflow:hidden}
button{position:absolute;top:16px;padding:10px 18px;border:none;border-radius:999px;background:#00d4ff;color:#031217;font-weight:700;cursor:pointer;box-shadow:0 8px 24px rgba(0,212,255,.25)}
#d{left:calc(50% - 80px)}#r{left:calc(50% + 10px)}
</style></head><body>
<button id="d" onclick="detonate()">Detonate</button>
<button id="r" onclick="reform()">Reform</button>
<script>
const scene=new THREE.Scene(),camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,.1,1500),renderer=new THREE.WebGLRenderer({antialias:true})
camera.position.set(0,20,160);renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(2,devicePixelRatio));renderer.outputColorSpace=THREE.SRGBColorSpace
document.body.appendChild(renderer.domElement)
const hemi=new THREE.HemisphereLight(0x9ad0ff,0x0a0c10,.8),rim=new THREE.DirectionalLight(0x22ffaa,1.0);rim.position.set(-120,60,-60);scene.add(hemi,rim)

// Digit textures
function tex(ch){const s=128,c=document.createElement("canvas");c.width=s;c.height=s;const x=c.getContext("2d")
x.fillStyle="#00e9ff";x.font="bold 96px monospace";x.textAlign="center";x.textBaseline="middle";x.fillText(ch,s/2,s/2)
const t=new THREE.CanvasTexture(c);t.colorSpace=THREE.SRGBColorSpace;return t}
const T1=tex("1"),T0=tex("0")
function sprite(map){return new THREE.Sprite(new THREE.SpriteMaterial({map:map,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false}))}

// Create dome points
const group=new THREE.Group();scene.add(group)
const radius=60,rows=36,cols=72,digits=[],domePos=[],vimanaPos=[]
for(let i=0;i<=rows;i++){
  const v=i/rows,phi=v*Math.PI/2
  const ringR=Math.cos(phi)*radius
  const y=Math.sin(phi)*radius
  const ringCount=Math.max(8,Math.floor(cols*Math.cos(phi)))
  for(let j=0;j<ringCount;j++){
    const u=j/ringCount,theta=u*2*Math.PI
    const x=Math.cos(theta)*ringR, z=Math.sin(theta)*ringR
    const pos=new THREE.Vector3(x+(Math.random()-0.5)*0.8,y+(Math.random()-0.5)*0.8,z+(Math.random()-0.5)*0.8)
    const s=sprite(Math.random()<0.5?T1:T0)
    const depth=pos.length(),scale=1.5-0.5*Math.min(1,depth/(radius*1.2))
    s.scale.set(scale,scale,1);s.material.opacity=0.35+0.55*Math.exp(-Math.abs(y)/radius*0.8)
    s.position.copy(pos);group.add(s);digits.push(s);domePos.push(pos.clone())
  }
}

// Create vimana positions (stepped pyramid)
for(let i=0;i<domePos.length;i++){
  const d=domePos[i]
  const level=Math.floor((d.y/radius)*6)
  const stepY=level*6
  const stepR=radius*(1-level/6)*0.8
  const angle=Math.atan2(d.z,d.x)
  const x=Math.cos(angle)*stepR+(Math.random()-0.5)*1.2
  const z=Math.sin(angle)*stepR+(Math.random()-0.5)*1.2
  vimanaPos.push(new THREE.Vector3(x,stepY,z))
}

function detonate(){
  digits.forEach(s=>{
    const outward=s.position.clone().normalize()
    const rnd=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize()
    const v=outward.multiplyScalar(18*(0.6+Math.random())).add(rnd.multiplyScalar(24*(0.4+Math.random())))
    s.userData.v=v
  })
}
function reform(){
  digits.forEach((s,i)=>{
    gsap.to(s.position,{x:vimanaPos[i].x,y:vimanaPos[i].y,z:vimanaPos[i].z,duration:1.6,ease:"power3.out"})
    s.userData.v=null
  })
}

let t=0
function animate(){
  requestAnimationFrame(animate)
  t+=0.01
  group.rotation.y=Math.sin(t*0.4)*0.14
  group.rotation.x=Math.cos(t*0.3)*0.06
  const dt=0.016
  digits.forEach(s=>{
    const v=s.userData.v
    if(v){
      s.position.addScaledVector(v,dt)
      v.multiplyScalar(0.984)
      s.material.opacity=Math.max(0.22, s.material.opacity*0.992)
    }else{
      s.material.opacity=Math.min(0.95, s.material.opacity+0.002)
    }
  })
  renderer.render(scene,camera)
}
animate()
onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)}
</script></body></html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binary Dome to Vimana</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
    }
    #ui {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      z-index: 10;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 18px;
      border-radius: 20px;
      border: none;
      background: #00cfff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="detonate">Detonate</button>
    <button id="reform">Reform</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Binary Particles
    const particleCount = 5000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount * 3);

    // Start positions = dome-shaped
    function generateDome() {
      for (let i = 0; i < particleCount; i++) {
        const phi = Math.random() * Math.PI / 2; // hemisphere
        const theta = Math.random() * Math.PI * 2;
        const radius = 30;
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi); // dome curvature
        const z = radius * Math.sin(phi) * Math.sin(theta);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        speeds[i * 3] = (Math.random() - 0.5) * 3;
        speeds[i * 3 + 1] = (Math.random() - 0.5) * 3;
        speeds[i * 3 + 2] = (Math.random() - 0.5) * 3;
      }
    }

    generateDome();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    // Material that displays 1s and 0s
    function generateTextSprite(text="1", color="#00ff55") {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = color;
      ctx.font = "bold 48px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, 32, 32);
      return new THREE.CanvasTexture(canvas);
    }

    const textures = [
      generateTextSprite("0", "#00ff55"),
      generateTextSprite("1", "#00ff55")
    ];

    const material = new THREE.PointsMaterial({
      size: 1.8,
      map: textures[0],
      transparent: true,
      depthWrite: false
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Animation flags
    let detonated = false;
    let reforming = false;

    document.getElementById("detonate").onclick = () => {
      detonated = true;
      reforming = false;
    };

    document.getElementById("reform").onclick = () => {
      detonated = false;
      reforming = true;
      reformToVimana();
    };

    // Reform target = tiered Vimana shape
    const targetPositions = new Float32Array(particleCount * 3);

    function reformToVimana() {
      const tiers = 10;          // number of temple tiers
      const tierHeight = 4;      // vertical spacing
      const baseRadius = 25;     // base width
      let index = 0;

      for (let t = 0; t < tiers; t++) {
        const tierY = t * tierHeight;
        const tierRadius = baseRadius * (1 - t/tiers); // tapering
        const columns = 40 - t*2; // fewer columns at top

        for (let c = 0; c < columns; c++) {
          const angle = (c / columns) * Math.PI * 2;
          const x = tierRadius * Math.cos(angle);
          const z = tierRadius * Math.sin(angle);

          // stack vertical column
          const colLevels = Math.max(2, 6 - t); // fewer levels at top
          for (let l = 0; l < colLevels; l++) {
            if (index >= particleCount) break;
            targetPositions[index*3] = x;
            targetPositions[index*3+1] = tierY + l*1.5;
            targetPositions[index*3+2] = z;
            index++;
          }
        }
      }

      // Apex spire
      for (let a = 0; a < 50 && index < particleCount; a++) {
        targetPositions[index*3] = (Math.random()-0.5)*2;
        targetPositions[index*3+1] = tiers*tierHeight + a*0.5;
        targetPositions[index*3+2] = (Math.random()-0.5)*2;
        index++;
      }

      // Switch to orange digits
      material.map = generateTextSprite("1", "#ff8800");
    }

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);

      const pos = geometry.attributes.position.array;

      if (detonated) {
        for (let i = 0; i < particleCount; i++) {
          pos[i * 3] += speeds[i * 3];
          pos[i * 3 + 1] += speeds[i * 3 + 1];
          pos[i * 3 + 2] += speeds[i * 3 + 2];
        }
      }

      if (reforming) {
        for (let i = 0; i < particleCount; i++) {
          pos[i * 3] += (targetPositions[i * 3] - pos[i * 3]) * 0.05;
          pos[i * 3 + 1] += (targetPositions[i * 3 + 1] - pos[i * 3 + 1]) * 0.05;
          pos[i * 3 + 2] += (targetPositions[i * 3 + 2] - pos[i * 3 + 2]) * 0.05;
        }
      }

      geometry.attributes.position.needsUpdate = true;
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

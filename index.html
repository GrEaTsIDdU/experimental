<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D ASCII Skull</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 140);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ASCII textures
    function makeCharTexture(char, color="#00ff99") {
      const cvs = document.createElement("canvas");
      cvs.width = 64; cvs.height = 64;
      const ctx = cvs.getContext("2d");
      ctx.clearRect(0,0,64,64);
      ctx.fillStyle = color;
      ctx.font = "bold 48px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(char, 32, 32);
      const tex = new THREE.CanvasTexture(cvs);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      return tex;
    }

    const glyphs = [
      makeCharTexture("0"), makeCharTexture("1"),
      makeCharTexture("@"), makeCharTexture("#"),
      makeCharTexture("X")
    ];

    function makeSprite(tex, opacity=1) {
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(2.2, 2.2, 1);
      return sp;
    }

    // Skull dimensions (voxel grid)
    const W = 72, H = 92, D = 28; // width, height, depth
    const scale = 1.15;

    // Helper: field functions for anatomy
    function skullField(nx, ny, nz) {
      // Base cranium (offset sphere)
      const cx = 0.46, cy = 0.47, cz = 0.5;
      const r = Math.sqrt((nx-cx)**2 + (ny-cy)**2 + (nz-cz)**2);

      // Jaw plane and curve
      const jaw = (ny > 0.64) && (nx < 0.55) && (ny < 0.92);
      const jawCurve = ny > 0.70 && (nx < 0.50) && (nz > 0.35) && (nz < 0.65);

      // Eye socket (carved hollow)
      const eye = Math.abs(nx - 0.33) < 0.07 && Math.abs(ny - 0.40) < 0.08 && nz > 0.30 && nz < 0.70;

      // Nasal cavity notch
      const nasal = Math.abs(nx - 0.40) < 0.04 && ny > 0.48 && ny < 0.60 && nz > 0.40 && nz < 0.60;

      // Cheekbone ridge
      const zygomatic = ny < 0.55 && ny > 0.35 && nx > 0.40 && nx < 0.65 && nz > 0.35 && nz < 0.70;

      // Base cranium threshold
      const head = r < 0.34;

      // Composite mask
      return head || jaw || jawCurve || zygomatic || nasal || eye;
    }

    // Build sprites
    const sprites = [];
    for (let z = 0; z < D; z++) {
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const nx = x / W, ny = y / H, nz = z / D;
          if (!skullField(nx, ny, nz)) continue;

          // Choose glyphs: eye = "@", teeth-ish rows = "#"
          const isEye = Math.abs(nx - 0.33) < 0.07 && Math.abs(ny - 0.40) < 0.08 && nz > 0.30 && nz < 0.70;
          const tex = isEye ? glyphs[2] : glyphs[Math.floor(Math.random() * glyphs.length)];

          // Depth-based opacity (shading)
          const depthShade = 0.35 + 0.6 * (1 - Math.abs((z - D/2) / (D/2)));
          const sp = makeSprite(tex, depthShade);

          sp.position.set(
            (x - W/2) * scale,
            (H/2 - y) * scale,
            (z - D/2) * scale
          );
          sprites.push(sp);
          scene.add(sp);
        }
      }
    }

    // Subtle cranial segmentation lines (extra glyph banding)
    for (let y = 18; y <= 72; y += 10) {
      for (let x = 8; x < W-8; x += 2) {
        const z = Math.floor(D/2);
        const nx = x / W, ny = y / H, nz = z / D;
        if (!skullField(nx, ny, nz)) continue;
        const sp = makeSprite(glyphs[4], 0.9); // X glyph highlight
        sp.position.set((x - W/2) * scale, (H/2 - y) * scale, (z - D/2) * scale);
        scene.add(sp);
      }
    }

    // Orbit animation
    function animate() {
      requestAnimationFrame(animate);
      const t = Date.now() * 0.00025;
      camera.position.x = 140 * Math.sin(t);
      camera.position.z = 140 * Math.cos(t);
      camera.position.y = 8 * Math.sin(t * 0.7);
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
